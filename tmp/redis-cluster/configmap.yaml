apiVersion: v1
data:
  cluster_health.sh: "#!/bin/sh\n\nset -e\n\nis_cluster_busy() {\n    CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn)\n
    \   CLUSTER_NODES=$(redis-cli -h \"$CLUSTER_NODE_DNS\" -p \"$PORT\" cluster nodes)\n\n
    \   # Check if any node is in slot migration or import\n    if echo \"$CLUSTER_NODES\"
    | grep -qE '\\[.*(importing|migrating).*]'; then\n        return 0\n    else        \n
    \       return 1\n    fi\n}\n\n# Returns 0 | 1 if the cluster is healty (all pods
    are available)\n# ====================================================\n# Check\n#
    echo $(check_initial_cluster_helth) => 1 | 0\n\ncheck_initial_cluster_helth()
    {\n    CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn)\n    \n    CLUSTER_STATE=$(redis-cli
    -h \"$CLUSTER_NODE_DNS\" -p 6379 cluster info | awk -F: '/cluster_state/ {print
    $2}' | tr -d '\\r\\n' | xargs)\n    CLUSTER_NODES=$(redis-cli -h \"$CLUSTER_NODE_DNS\"
    -p 6379 cluster info | awk 'NR==6' | cut -d: -f2)\n    CLUSTER_MASTERS=$(redis-cli
    -h \"$CLUSTER_NODE_DNS\" -p 6379 cluster info | awk 'NR==7' | cut -d: -f2)\n\n
    \   if [ \"$CLUSTER_STATE\" != \"ok\" ]; then\n        return 0\n    elif [ \"$CLUSTER_MASTERS\"
    -eq \"0\" ]; then\n        return 0\n    elif [ \"$CLUSTER_NODES\" -eq \"0\" ];
    then\n        return 0\n    elif [ \"$CLUSTER_NODES\" -lt \"$REPLICAS\" ]; then\n
    \       return 0\n    fi\n   \n\n    TOTAL_GROUP_MEMBERS=$(( CLUSTER_REPLICAS
    + 1 ))\n    RATIO=$(( REPLICAS / TOTAL_GROUP_MEMBERS ))\n    REVERSE_CHECK=$((
    RATIO * TOTAL_GROUP_MEMBERS ))\n\n    if [ \"$REPLICAS\" -ne \"$REVERSE_CHECK\"
    ]; then\n        return 0\n    else \n        return 1\n    fi     \n}\n\nslot_distribution_checker()
    {\n    CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn)\n    SLOTS_NUM=16384\n\n
    \   # IF THE CLUSTER IS IN THE MERGING OR IMPORTING MODE\n    if is_cluster_busy;
    then\n        printf \"CLUSTER BUSSY \\n\" >&2\n        return 1\n\n    # IF THE
    CLUSTER IS NOT IN THE MERGING OR IMPORTING MODE\n    else\n\n        # CHECK FOR
    0 SLOTS MASTER\n        SLOTS_0=$(redis-cli --cluster check \"$CLUSTER_NODE_DNS:$PORT\"
    | grep 'slots |' | awk -F'|' '{print $2}' | awk '{print $1}' | grep '^0$')\n\n
    \       # IF THERE IS AT LEAST 1 EMPTY MASTER WITH 0 SLOTS\n        if [ -n \"$SLOTS_0\"
    ]; then\n\n            # GET THE SLOTS WITHOUT 0\n            # WE DO THIS BECAUSE
    A NEW MASTER IS ADDED JUST WITH 0 SLOTS BUT THE CLUSTER IS NOT BUSSY\n            #
    IT MEANS THE REBALANCE IS NOT CALLED YET. THE CLUSTER STILL RECEIVES NODES\n            SLOTS=$(redis-cli
    --cluster check \"$CLUSTER_NODE_DNS:$PORT\" | grep 'slots |' | awk -F'|' '{print
    $2}' | awk '{print $1}' | grep -v '^0$')\n            \n            # GET THE
    COUNT OF THE NON 0 SLOTS\n            SLOTS_COUNT=$(echo \"$SLOTS\" | wc -l)\n
    \       else\n             # GET THE SLOT NUMER\n            SLOTS=$(redis-cli
    --cluster check \"$CLUSTER_NODE_DNS:$PORT\" | grep 'slots |' | awk -F'|' '{print
    $2}' | awk '{print $1}')\n\n            # GET THE COUNT OF THE NON 0 SLOTS\n            SLOTS_COUNT=$(echo
    \"$SLOTS\" | wc -l)\n        fi\n\n        # IF THE CLUSTER SLOT COUNT IS 0 OR
    1 MEANS THE CLUSTER IS NOT READY. WE CAN'T HAVE CLUSTER WITH 1 NODE ONLY\n        if
    [ \"$SLOTS_COUNT\" -eq 0 ] || [ \"$SLOTS_COUNT\" -eq 1 ]; then\n            print_yellow
    \"CLUSTER NOT READY\" 1 >&2\n            return 1\n        fi\n\n        # GET
    THE MIN AND MAX SLOT NUMBER DISTRIBUTION ACCROSS THE MASTERS\n        # THIS IS
    PRE CALC FOR CHECKING\n        FINAL_DISTRIBUTION_MIN=$((SLOTS_NUM / SLOTS_COUNT))\n
    \       FINAL_DISTRIBUTION_MAX=$(math_ceil \"$SLOTS_NUM/$SLOTS_COUNT\")\n\n        #
    GET THE MIN MAX SLOT NUMBER DISTRIBUTION IN THE ACTUAL CLUSTER\n        # THIS
    IS WHAT THE CLUSTER HAS NOW\n        VALUE_MIN=$(get_min \"$SLOTS\")\n        VALUE_MAX=$(get_max
    \"$SLOTS\")\n\n        # IF PRE CALC MIN AND MAX ARE NOT EQUAL TO THE ACTUAL MIN
    MAX, PROBABLY WE HAVE REDISTRIBUTION\n        # NOTE: THE SCRIPT IS BUILT FOR
    SYMETRIC CLUSTER\n        if [ \"$FINAL_DISTRIBUTION_MIN\" -ne \"$VALUE_MIN\"
    ] || [ \"$FINAL_DISTRIBUTION_MAX\" -ne \"$VALUE_MAX\" ]; then\n            printf
    \"REDISTRIBUTING \\n\" >&2\n            return 1\n        \n        # THE CLUSTER
    HAS THE CORRECT DISTRIBUTION AND THERE IS JUST A NEW MASTER/S WITH 0 SLOTS\n        #
    NEXT THE CLUSTER MUST BE REBALANCED\n        else\n            printf \"CLUSTER
    STABLE \\n\" >&2\n            return 0\n        fi        \n    fi\n}\n\noperation_loop()
    {\n    while true; do\n        if slot_distribution_checker; then\n            printf
    \"Cluster is stable, exiting loop.\"\n            break\n        fi\n\n        printf
    \"Cluster not stable, retrying in 2 seconds...\"\n        sleep 2\n    done\n}\n\n#
    redis-cli --cluster check \"redis-node-0.redis-service.authentication.svc.cluster.local:6379\"
    | grep 'slots |' | awk -F'|' '{print $2}' | awk '{print $1}'\n# redis-cli --cluster
    check \"redis-node-0.redis-service.authentication.svc.cluster.local:6379\"\n"
  cluster_scaling.sh: "#!/bin/sh\n\n# For Debug\n# set -x\nset -e\n\nadd_new_master()
    {\n    operation_loop\n\n    POD_DNS=$(create_pod_dns)\n    add_empty_master \"$POD_DNS\"\n}\n\nslave_controller()
    {\n    POD_DNS=$(create_pod_dns)\n    IS_LAST_SLAVE=$(is_last_slave \"$REDIS_NODE_ID\"
    \"$CLUSTER_REPLICAS\")\n\n    operation_loop\n    add_replica \"$POD_DNS\"\n\n
    \   if [ \"$IS_LAST_SLAVE\" -eq 1 ]; then\n        print_yellow \"This is the
    LAST SLAVE NODE, running rebalance...\" 1            \n        \n        operation_loop\n
    \       call_rebalance\n        \n    fi\n}\n\ninit_scale_node() {\n\n    if check_initial_cluster_helth;
    then\n        print_red \"CLUSTER IS NOT HEALTY!\" 1\n        return 1\n    fi\n\n
    \   # GET AT LEAST ONE HEALTY CLUSTER NODE DNS\n    CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn)\n\n
    \   # GET THE POD DNS IF IT IS A PART OF A CLUSTER\n    POD_CLUSTER_DNS=$(redis-cli
    -p \"$PORT\" cluster nodes | grep myself | awk '{ print $2 }' | cut -d: -f1)\n\n
    \   # IS THIS NODE A PART OF A CLUSTER\n    PART_OF_CLUSTER=$([ -n \"$POD_CLUSTER_DNS\"
    ] && echo 1 || echo 0)\n\n\n    if [ \"$PART_OF_CLUSTER\" -eq \"1\" ]; then\n
    \       print_yellow \"This is node is already a part of the cluster masters\"
    1\n        print_green \"redis-cli -p \"\"$PORT\"\" cluster nodes | grep master\"
    1\n\n        return 0\n    fi\n\n    # CHECKS IF THE NEW CURRENT POD STATUS 0
    | 1 - 1 MEANS IT SHOULD BE A MASTER\n    IS_MASTER=$(is_master \"$REDIS_NODE_ID\"
    \"$CLUSTER_REPLICAS\")\n\n    # CHECKS IF THE NEW CURRENT POD STATUS 0 | 1 - 1
    MEANS IT SHOULD BE A SLAVE\n    IS_SLAVE=$(is_slave \"$REDIS_NODE_ID\" \"$CLUSTER_REPLICAS\")\n\n
    \   if [ \"$IS_MASTER\" -eq 1 ]; then\n        print_yellow \"This is MASTER NODE\"
    1\n        print_yellow \"This node will be a part of the cluster as a empty master.
    The last replica will setup and rebalance the cluter.\"\n        print_yellow
    \"Current master nodes\"\n        print_green \"redis-cli -h \"\"$CLUSTER_NODE_DNS\"\"
    -p \"\"$PORT\"\" cluster nodes | grep master\" 1\n\n        add_new_master\n\n
    \       print_green \"redis-cli -h \"\"$CLUSTER_NODE_DNS\"\" -p \"\"$PORT\"\"
    cluster nodes | grep master\" 1\n    fi\n\n    if [ \"$IS_SLAVE\" -eq 1 ]; then\n
    \       slave_controller\n    fi\n\n    return 0\n}"
  cluster_tools.sh: "#!/bin/sh\n\nset -e\n\n# Returns the first healthy node dns from
    the initial cluster\n# ====================================================\n#
    Check\n# echo $(get_healthy_cluster_node_dsn) => redis-node-0.redis-service.authentication.svc.cluster.local\nget_healthy_cluster_node_dsn()
    {    \n    INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\" \"$SERVICE_NAME\"
    \"$NAMESPACE\" \"$POD_NAME\")\n\tREADY_NODE=\"\"\n\n\twhile [ -z \"$READY_NODE\"
    ]; do\n\t    for node in $INITIAL_NODES; do\n\t        if redis-cli -h \"$node\"
    ping | grep -q PONG; then\n\t            READY_NODE=$node\n                print_green
    \"Found: $READY_NODE\" 1 >&2\n\t            break\n\t        fi\n\t    done\n\t
    \   \n\t    if [ -z \"$READY_NODE\" ]; then\n\t        print_yellow \"No available
    healty nodes, retrying in 2 seconds...\" 1 >&2\n\t        sleep 2\n\t    fi\n\tdone\n\n\techo
    \"$node\"\n}\n\n# Returns the master node dns from the pod froup\n# ====================================================\n#
    Check\n# echo $(get_group_master_node) => redis-node-8.redis-service.authentication.svc.cluster.local\nget_group_master_node()
    {\n    GROUP_SET=$(group_pods \"$REDIS_NODE_ID\" \"$CLUSTER_REPLICAS\")\n    GROUP_DNS=$(construct_node_set
    \"$GROUP_SET\" \"$SERVICE_NAME\" \"$NAMESPACE\" \"$POD_NAME\")\n\n    print_green
    \"GROUP_SET: $GROUP_SET\"\n    print_green \"GROUP_DNS: $GROUP_DNS\"\n\n    MASTER_NODE=\"\"\n
    \   while [ -z \"$MASTER_NODE\" ]; do\n        for node in $GROUP_DNS; do\n            if
    redis-cli -h \"$node\" ping | grep -q PONG; then\n\n                NODE_ID=$(redis-cli
    -h \"$node\" -p \"$PORT\" cluster myid)\n                ROLE=$(redis-cli -h \"$node\"
    -p \"$PORT\" cluster nodes | awk -v id=\"$NODE_ID\" '$1 == id { print $3 }' |
    grep master || true)\n\n                if [ -n \"$ROLE\" ]; then                    \n
    \                   MASTER_NODE=$node\n                    print_green \"Found
    MASTER: $MASTER_NODE\" 1\n                    break\n                fi\n            fi\n
    \       done\n        \n        if [ -z \"$MASTER_NODE\" ]; then\n            print_yellow
    \"No master node available in the group, retrying in 2 seconds...\" 1\n            sleep
    2\n        fi\n    done\n\n    echo \"$MASTER_NODE\"\n}\n\n\n# Returns the master
    ID by providing the master dns\n# ====================================================\n#
    Check\n# echo $(get_master_node_id) => a8g765s...\nget_master_node_id() {\n    MASTER_NODE=\"$1\"\n\n
    \   RESULT=$(redis-cli -h \"$MASTER_NODE\" -p \"$PORT\" cluster nodes | awk '$3
    ~ /master/ { print $1; exit }')\n    echo \"$RESULT\"\n}\n\n\n# Adds new empty
    master to the cluster by providing pod DNS\n# ===========================================================\nadd_empty_master()
    {\n    POD_DNS=\"$1\"\n\n    MAX_RETRIES=5\n    RETRY_DELAY=2  # seconds (initial
    delay)\n    ATTEMPT=1\n\n    INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\"
    \"$SERVICE_NAME\" \"$NAMESPACE\" \"$POD_NAME\")\n\n    while [ \"$ATTEMPT\" -le
    \"$MAX_RETRIES\" ]; do\n        CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n\n        print_green \"Attempt $ATTEMPT: Adding empty master
    $POD_DNS to cluster via $CLUSTER_NODE_DNS:$PORT\" 1\n        print_green \"Adding:
    $POD_DNS\" 1\n\n        if redis-cli --cluster add-node \"$POD_DNS\" \"$CLUSTER_NODE_DNS:$PORT\"
    --cluster-slots 0; then\n            print_green \"Successfully added node $POD_DNS
    to the cluster.\" 1\n            return 0\n        else\n            print_yellow
    \"Failed to add node. Retrying in $RETRY_DELAY seconds...\" 1\n            sleep
    \"$RETRY_DELAY\"\n            RETRY_DELAY=$((RETRY_DELAY * 2))  # exponential
    backoff\n            ATTEMPT=$((ATTEMPT + 1))\n        fi\n    done\n\n    print_red
    \"ERROR: Failed to add node $POD_DNS to the cluster after $MAX_RETRIES attempts.\"
    1\n    return 1\n}\n\n\n# Adds new slave\\follower\\replica to the cluster by
    providing pod replica DNS\n# ===========================================================================\nadd_replica()
    {\n    REPLICA_POD_DNS=\"$1\"\n    MAX_RETRIES=5\n    RETRY_DELAY=2  # initial
    delay in seconds\n    ATTEMPT=1\n\n    INITIAL_NODES=$(construct_initial_node_set
    \"$REPLICAS\" \"$SERVICE_NAME\" \"$NAMESPACE\" \"$POD_NAME\")\n\n    while [ \"$ATTEMPT\"
    -le \"$MAX_RETRIES\" ]; do\n        CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n        GROUP_MASTER_NODE=$(get_group_master_node)\n        GROUP_MASTER_NODE_ID=$(get_master_node_id
    \"$GROUP_MASTER_NODE\")\n\n        print_green \"Attempt $ATTEMPT: Adding replica
    $REPLICA_POD_DNS to follow $GROUP_MASTER_NODE_ID via $CLUSTER_NODE_DNS:$PORT\"\n\n
    \       if redis-cli --cluster add-node \"$REPLICA_POD_DNS\" \"$CLUSTER_NODE_DNS:$PORT\"
    --cluster-slave --cluster-master-id \"$GROUP_MASTER_NODE_ID\"; then\n            print_green
    \"Successfully added replica $REPLICA_POD_DNS to follow master $GROUP_MASTER_NODE_ID\"
    1\n            return 0\n        else\n            print_yellow \"Failed to add
    replica. Retrying in $RETRY_DELAY seconds...\" 1\n            sleep \"$RETRY_DELAY\"\n
    \           RETRY_DELAY=$((RETRY_DELAY * 2))  # exponential backoff\n            ATTEMPT=$((ATTEMPT
    + 1))\n        fi\n    done\n\n    print_yellow \"ERROR: Failed to add replica
    $REPLICA_POD_DNS after $MAX_RETRIES attempts.\"\n    return 1\n}\n\n\n# A special
    REDIS command, when unexpected error happens.\n# ===========================================================================\ncall_cluster_fix()
    {\n    CLUSTER_NODE_DNS=\"$1\"\n    MAX_RETRIES=5\n    RETRY_DELAY=5\n    ATTEMPT=1\n\n
    \   while [ \"$ATTEMPT\" -le \"$MAX_RETRIES\" ]; do\n        if redis-cli --cluster
    fix \"$CLUSTER_NODE_DNS:$PORT\"; then\n            echo \"Cluster fix succeeded.\"\n
    \           break\n        else\n            echo \"Cluster fix failed. Retrying
    in $RETRY_DELAY seconds...\"\n            sleep \"$RETRY_DELAY\"\n            ATTEMPT=$((ATTEMPT
    + 1))\n        fi\n    done\n\n    if [ \"$ATTEMPT\" -gt \"$MAX_RETRIES\" ]; then\n
    \       echo \"Cluster fix failed after $MAX_RETRIES attempts.\"\n        exit
    1\n    fi\n}\n\n# A special REDIS command, for slot rebalancing accross the masters\n#
    ===========================================================================\ncall_rebalance()
    {\n    INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\" \"$SERVICE_NAME\"
    \"$NAMESPACE\" \"$POD_NAME\")\n    MAX_RETRIES=5\n    RETRY_DELAY=2  # seconds\n
    \   ATTEMPT=1\n\n    while [ \"$ATTEMPT\" -le \"$MAX_RETRIES\" ]; do\n        CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n\n        print_green \"Attempt $ATTEMPT: Rebalancing cluster
    via $CLUSTER_NODE_DNS:$PORT\" 1\n\n        if redis-cli --cluster rebalance --cluster-use-empty-masters
    \"$CLUSTER_NODE_DNS:$PORT\"; then\n            print_green \"Rebalance succeeded.\"
    1\n            return 0\n        else\n            print_yellow \"Rebalance failed.
    Retrying in $RETRY_DELAY seconds...\" 1\n            call_cluster_fix \"$CLUSTER_NODE_DNS\"\n\n
    \           sleep \"$RETRY_DELAY\"\n            RETRY_DELAY=$((RETRY_DELAY * 2))\n
    \           ATTEMPT=$((ATTEMPT + 1))\n        fi\n    done\n\n    print_red \"ERROR:
    Failed to rebalance cluster after $MAX_RETRIES attempts.\" 1\n    return 1\n}\n\nget_rest_master_id_list()
    {\n    INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\" \"$SERVICE_NAME\"
    \"$NAMESPACE\" \"$POD_NAME\")\n    CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n    MYID=$(get_my_node_id)\n    \n    RESULT=$(redis-cli
    -h \"$CLUSTER_NODE_DNS\" -p \"$PORT\" cluster nodes | awk -v myid=\"$MYID\" '$3
    ~ /master/ && $1 != myid {print $1}')\n\n    echo \"$RESULT\"\n}\n\nget_rest_master_id_list_comma()
    {\n    INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\" \"$SERVICE_NAME\"
    \"$NAMESPACE\" \"$POD_NAME\")\n    CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n    MYID=$(get_my_node_id)  # ← Ensure your current node
    ID is available\n\n    RESULT=$(redis-cli -h \"$CLUSTER_NODE_DNS\" -p \"$PORT\"
    cluster nodes | awk -v myid=\"$MYID\" '\n        $3 ~ /master/ && $1 != myid {\n
    \           ids = (ids == \"\" ? $1 : ids \",\" $1)\n        }\n        END {
    print ids }\n    ')\n\n    echo \"$RESULT\"\n}\n\nget_first_rest_master_id() {\n
    \   INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\" \"$SERVICE_NAME\"
    \"$NAMESPACE\" \"$POD_NAME\")\n    CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n\n    FIRST_ID=$(redis-cli -h \"$CLUSTER_NODE_DNS\" -p \"$PORT\"
    cluster nodes | awk -v myid=\"$MYID\" '\n        $3 ~ /master/ && $1 != myid {
    print $1; exit }\n    ')\n\n    echo \"$FIRST_ID\"\n}\n\nget_my_node_id() {\n
    \   CURRENT_NODE_ID=$(redis-cli -p \"$PORT\" cluster myid)\n    echo \"$CURRENT_NODE_ID\"\n}\n\nmove_all_slots_to_masters()
    {\n    MAX_RETRIES=5\n    RETRY_DELAY=2  # seconds\n    ATTEMPT=1\n\n    while
    [ \"$ATTEMPT\" -le \"$MAX_RETRIES\" ]; do\n        # MASTER_ID_LIST=$(get_rest_master_id_list_comma)\n
    \       CURRENT_MASTER_ID=$(get_my_node_id)\n        # INTIAL_MASTER_ID=$(get_first_rest_master_id)\n\n
    \       INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\" \"$SERVICE_NAME\"
    \"$NAMESPACE\" \"$POD_NAME\")    \n        CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n\n        print_green \"Attempt $ATTEMPT: Resharding cluster
    slots\" 1\n\n        CLUSTER_TO_ARGS=$(get_rest_master_id_list | awk '{printf
    \"--cluster-to %s \", $0}')        \n        \n        if redis-cli --cluster
    reshard \"$CLUSTER_NODE_DNS:$PORT\" --cluster-from \"$CURRENT_MASTER_ID\" $CLUSTER_TO_ARGS
    --cluster-slots 16500 --cluster-yes; then\n            print_green \"Resharding
    succeeded.\" 1\n            return 0\n        else\n            print_yellow \"Resharding
    failed. Retrying in $RETRY_DELAY seconds...\" 1\n            CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn
    \"$INITIAL_NODES\")\n            call_cluster_fix \"$CLUSTER_NODE_DNS\"\n\n            sleep
    \"$RETRY_DELAY\"\n            RETRY_DELAY=$(( RETRY_DELAY * 2 ))\n            ATTEMPT=$((
    ATTEMPT + 1 ))\n        fi\n    done\n\n    print_red \"ERROR: Failed to reshard
    master slots after $MAX_RETRIES attempts.\" 1\n    return 1\n}\n\ndelete_current_cluster_node()
    {\n    MAX_RETRIES=5\n    RETRY_DELAY=2  # seconds\n    ATTEMPT=1\n\n    # Get
    your current node ID (the one to delete)\n    CURRENT_NODE_ID=$(get_my_node_id)\n\n
    \   while [ \"$ATTEMPT\" -le \"$MAX_RETRIES\" ]; do\n        # Get a healthy cluster
    node to connect to (not the node to delete)\n        CLUSTER_NODE_DNS=$(get_healthy_cluster_node_dsn)\n\n
    \       if redis-cli --cluster del-node \"$CLUSTER_NODE_DNS:$PORT\" \"$CURRENT_NODE_ID\";
    then\n            print_green \"Node deleted successfully.\" 1\n            return
    0\n        else\n            print_yellow \"Node delete process failed. Retrying
    in $RETRY_DELAY seconds...\" 1\n            call_cluster_fix \"$CLUSTER_NODE_DNS\"\n\n
    \           sleep \"$RETRY_DELAY\"\n            RETRY_DELAY=$(( RETRY_DELAY *
    2 ))\n            ATTEMPT=$(( ATTEMPT + 1 ))\n        fi\n    done\n\n    print_red
    \"ERROR: Failed to delete the node after $MAX_RETRIES attempts.\" 1\n    return
    1\n}\n"
  commando.sh: "#!/bin/sh\n\nset -e\n\nPORT=${PORT:-6379}\nCLUSTER_NODE_TIMEOUT=${CLUSTER_NODE_TIMEOUT:-5000}\nPOD_INDEX=${POD_NAME_INDEX##*-}\nREDIS_NODE_ID=$(expr
    \"$POD_INDEX\" + 1)\nPOD_NAME=\"${POD_NAME_INDEX%-[0-9]*}\"\n\nif [ -z \"$MOUNT_POINT\"
    ]; then\n    printf \"MOUNT_POINT is missing: Please privide value!\"\n    exit
    1\nfi\n\nif [ -z \"$POD_NAME\" ]; then\n    printf \"POD_NAME is missing: Please
    privide value!\"\n    exit 1\nfi\n\nif [ -z \"$REPLICAS\" ]; then\n    printf
    \"REPLICAS is missing: Please privide value!\"\n    exit 1\nfi\n\nif [ -z \"$CLUSTER_REPLICAS\"
    ]; then\n    printf \"CLUSTER_REPLICAS is missing: Please privide value!\"\n    exit
    1\nfi\n\nif [ -z \"$SERVICE_NAME\" ]; then\n    printf \"SERVICE_NAME is missing:
    Please privide value!\"\n    exit 1\nfi\n\nif [ -z \"$NAMESPACE\" ]; then\n    printf
    \"NAMESPACE is missing: Please privide value!\"\n    exit 1\nfi\n\nif [ -z \"$NAMESPACE\"
    ]; then\n    printf \"NAMESPACE is missing: Please privide value!\"\n    exit
    1\nfi\n\n. \"$MOUNT_POINT/global_tools.sh\"\n. \"$MOUNT_POINT/cluster_tools.sh\"\n.
    \"$MOUNT_POINT/orchestrate.sh\"\n. \"$MOUNT_POINT/cluster_health.sh\"\n. \"$MOUNT_POINT/default_cluster.sh\"\n.
    \"$MOUNT_POINT/cluster_scaling.sh\"\n. \"$MOUNT_POINT/init_cluster.sh\"\n\nprint_green
    \"INTITIALIZING ....\" 1\n\ninit \"$REDIS_NODE_ID\" \"$CLUSTER_REPLICAS\" \"$REPLICAS\"
    \"$SERVICE_NAME\" \"$NAMESPACE\" \"$POD_NAME\" \"$PORT\" & \n\n# --- Signal Handling
    Setup ---\nterm_handler() {\n    echo \"[Entrypoint] SIGTERM received. Waiting
    for prestop to finish...\"\n    while [ ! -f /tmp/prestop-done ]; do\n        sleep
    1\n    done\n    echo \"[Entrypoint] Prestop completed. Sending SIGTERM to Redis...\"\n
    \   kill -TERM \"$REDIS_PID\"\n}\n\ntrap term_handler TERM\n\n# Start Redis in
    background\n# redis-server --port \"$PORT\" \\\n#              --cluster-enabled
    yes \\\n#              --cluster-config-file nodes.conf \\\n#              --cluster-node-timeout
    \"$CLUSTER_NODE_TIMEOUT\" \\\n#              --appendonly yes &\n\n# redis-server
    --port 0 \\\n#              --tls-port \"$PORT\" \\\n#              --tls-cert-file
    \"/tls/tls.crt\" \\\n#              --tls-key-file \"/tls/tls.key\" \\\n#              --tls-ca-cert-file
    \"/tls/ca.crt\" \\\n#              --tls-auth-clients \"yes\" \\\n#              --cluster-enabled
    yes \\\n#              --cluster-config-file nodes.conf \\\n#              --cluster-node-timeout
    \"$CLUSTER_NODE_TIMEOUT\" \\\n#              --appendonly yes &\n\n# REDIS_PID=$!\n\n#
    Wait for Redis\nwhile kill -0 \"$REDIS_PID\" 2>/dev/null; do\n    wait \"$REDIS_PID\"\ndone"
  default_cluster.sh: "#!/bin/sh\n\n# For Debug\n# set -x\nset -e\n\n# Check if the
    current node persists in the cluster\n# ==================================================\nis_node_in_cluster()
    {\n    port=$1\n    output=$(redis-cli -p \"$port\" cluster info 2>/dev/null |
    grep cluster_state)\n\n    if echo \"$output\" | grep -q \"ok\"; then\n        echo
    \"1\" \n    else\n        echo \"0\" \n    fi\n}\n\n# Once all initial nodes are
    ready, the last one call\n# calls this function. The function setup the initial\n#
    cluster\n# ==================================================\nsetup_initial_cluster()
    {\n    REPLICAS=$1\n    SERVICE_NAME=$2\n    NAMESPACE=$3\n    POD_NAME=$4\n    PORT=$5\n
    \   CLUSTER_REPLICAS=$6\n\n    INITIAL_NODES=$(construct_initial_node_set \"$REPLICAS\"
    \"$SERVICE_NAME\" \"$NAMESPACE\" \"$POD_NAME\")\n    INITIAL_NODES_PORT=$(construct_initial_node_set_port
    \"$REPLICAS\" \"$SERVICE_NAME\" \"$NAMESPACE\" \"$POD_NAME\" \"$PORT\")\n\n    printf
    \"\\\\n⏳ Waiting for Redis nodes to be healthy...\\\\n\";\n    for node in $INITIAL_NODES;
    do\n        until redis-cli -h $node ping | grep -q PONG; do\n            printf
    \"\\\\n Waiting for %s... \\\\n\" \"$node\"\n            sleep 2;\n        done;\n
    \   done;\n\n    print_green \"\U0001F680 Creating Redis cluster...\" 1;\n    print_green
    'yes yes | redis-cli --cluster create %s --cluster-replicas %s\\\\n' \"$INITIAL_NODES_PORT\"
    \"$CLUSTER_REPLICAS\" 2\n    \n    yes yes | redis-cli --cluster create $INITIAL_NODES_PORT
    --cluster-replicas \"$CLUSTER_REPLICAS\"\n   \n    print_green \"✅ Redis cluster
    initialized!\" 1\n}\n\n# Start point for initial cluster setup\n# ==================================================\ninit_initial_node()
    {\n    REDIS_NODE_ID=$1\n    CLUSTER_REPLICAS=$2\n    REPLICAS=$3\n    SERVICE_NAME=$4\n
    \   NAMESPACE=$5\n    POD_NAME=$6\n    PORT=$7\n\n    print_green \"Starting Initial
    Node script ....\" 1\n\n    in_cluster=$(is_node_in_cluster \"$PORT\" \"$REDIS_NODE_ID\"
    \"$CLUSTER_REPLICAS\")    \n\n    [ \"$REDIS_NODE_ID\" -eq \"$REPLICAS\" ] &&
    last_initial_node=1 || last_initial_node=0\n\n    print_green \"================================\"\n
    \   print_green \"\U0001F680 in_cluster. ${in_cluster}\"\n    print_green \"\U0001F680
    last_initial_node ${last_initial_node}\"\n    print_green \"================================\"\n\n
    \   # if the node is initial node and is not a part of the cluster yet\n    if
    [ \"$in_cluster\" -eq 0 ]; then\n        # If the cluster is not ready and this
    is the last node\n        # Setup the initial cluster\n        if [ \"$last_initial_node\"
    -eq 1 ]; then\n\n            print_green \"================================\"\n
    \           print_green \"\U0001F680 This is the last node. It will create the
    initial cluster.\"\n            print_green \"⏳ Creating ...\"\n            print_green
    \"================================\"\n\n            setup_initial_cluster \"$REPLICAS\"
    \"$SERVICE_NAME\" \"$NAMESPACE\" \"$POD_NAME\" \"$PORT\" \"$CLUSTER_REPLICAS\"\n
    \       else \n            print_yellow \"✅ This is initial node! This node is
    not the last node in the group. it will wait for the last node to setup the cluster.\"
    1\n        fi\n    else\n        # Else this node is already part of the initial
    \n        # node group and it was failed or restarted\n        # In this case
    skip, the redis will handle it\n\n        print_yellow \"✅ This node is already
    a part of the cluster.\" 1\n    fi\n}\n"
  global_tools.sh: |-
    #!/bin/sh

    set -e

    # Green Printer
    # =============
    print_green() {
        TEXT=$1
        BORDER=${2:-0}

        if [ "$BORDER" -eq 1 ]; then
            printf "\n" >&2
            printf "\033[0;32m %s \033[0m" "=====================================" >&2
            printf "\n" >&2
            printf "\033[0;32m %s \033[0m" "$TEXT" >&2
            printf "\n" >&2
            printf "\033[0;32m %s \033[0m" "=====================================" >&2
            printf "\n" >&2
        else
            printf "\n" >&2
            printf "\033[0;32m %s \033[0m" "$TEXT" >&2
            printf "\n" >&2
        fi
    }

    # Yellow Printer
    # =============
    print_yellow() {
        TEXT=$1
        BORDER=${2:-0}

        if [ "$BORDER" -eq 1 ]; then
            printf "\n" >&2
            printf "\033[0;33m %s \033[0m" "=====================================" >&2
            printf "\n" >&2
            printf "\033[0;33m %s \033[0m" "$TEXT" >&2
            printf "\n" >&2
            printf "\033[0;33m %s \033[0m" "=====================================" >&2
            printf "\n" >&2
        else
            printf "\n" >&2
            printf "\033[0;33m %s \033[0m" "$TEXT" >&2
            printf "\n" >&2
        fi
    }

    # Red Printer
    # =============
    print_red() {
        TEXT=$1
        BORDER=${2:-0}

        if [ "$BORDER" -eq 1 ]; then
            printf "\n" >&2
            printf "\033[0;31m %s \033[0m" "=====================================" >&2
            printf "\n" >&2
            printf "\033[0;31m %s \033[0m" "$TEXT" >&2
            printf "\n" >&2
            printf "\033[0;31m %s \033[0m" "=====================================" >&2
            printf "\n" >&2
        else
            printf "\n" >&2
            printf "\033[0;31m %s \033[0m" "$TEXT" >&2
            printf "\n" >&2
        fi
    }

    # Returns the base of the floating number: 123.123 -> 123
    # ====================================================
    math_floor() {
        awk -v n="$1" 'BEGIN { printf("%d", int(n)) }'
    }

    # Returns the next whole number of the floating number: 123.123 -> 124
    # ====================================================
    math_ceil() {
        expr="$1"
        awk "BEGIN { result = $expr; printf \"%d\n\", (result == int(result)) ? result : int(result)+1 }"
    }

    # Returns the min value from a set with numbers
    # ====================================================
    get_min() {
        min=""
        for n in $(printf '%s\n' "$1"); do
            [ -z "$min" ] && min=$n
            [ "$n" -lt "$min" ] && min=$n
        done
        echo "$min"
    }

    # Returns the max value from a set with numbers
    # ====================================================
    get_max() {
        max=""
        for n in $(printf '%s\n' "$1"); do
            [ -z "$max" ] && max=$n
            [ "$n" -gt "$max" ] && max=$n
        done
        echo "$max"
    }
  init_cluster.sh: "#!/bin/sh\n\n# For Debug\n# set -x\nset -e\n\n# This function
    checks the current node\n# is the node a part of the initial\n# cluster group\n#
    =====================================\nis_initial_node() {\n    REDIS_NODE_ID=$1\n
    \   REPLICAS=$2\n\n    if [ \"$REDIS_NODE_ID\" -le \"$REPLICAS\" ]; then\n        echo
    \"1\" \n    else\n        echo \"0\"\n    fi\n}\n\n# The startpoint for initial
    cluster\n# Detects if the node must be initial cluster\n# or part of the scaling
    process\n# ============================================\ninit() {\n\n    REDIS_NODE_ID=$1\n
    \   CLUSTER_REPLICAS=$2\n    REPLICAS=$3\n    SERVICE_NAME=$4\n    NAMESPACE=$5\n
    \   POD_NAME=$6\n\n    sleep 2\n\n    print_green \"===============================================\"\n
    \   print_green \"NODE with parameters:\"\n    print_green \"REDIS_NODE_ID: ${REDIS_NODE_ID}\"\n
    \   print_green \"POD_NAME: ${POD_NAME}\"\n    print_green \"CLUSTER_REPLICAS:
    ${CLUSTER_REPLICAS}\"\n    print_green \"REPLICAS: ${REPLICAS}\"\n    print_green
    \"SERVICE_NAME: ${SERVICE_NAME}\"\n    print_green \"NAMESPACE: ${NAMESPACE}\"\n
    \   print_green \"===============================================\"\n\n    initial_node=$(is_initial_node
    \"$REDIS_NODE_ID\" \"$REPLICAS\")\n\n    if [ \"$initial_node\" -eq 1 ]; then\n
    \       # If the node is part of the initial group nodes for the initial cluster\n
    \       init_initial_node \"$@\"\n    else\n        # If not a part of the initial
    group, we have to treat it like scale node\n        max_retries=5\n        count=0\n
    \       until init_scale_node \"$@\"; do\n            count=$((count + 1))\n            echo
    \"init_scale_node failed, retry #$count...\"\n            if [ \"$count\" -ge
    \"$max_retries\" ]; then\n                echo \"Max retries reached, exiting.\"\n
    \               exit 1\n            fi\n            sleep 5  # wait before retrying\n
    \       done\n    fi\n}\n"
  orchestrate.sh: "#!/bin/sh\n\nset -e\n\n# Returns the node number in the cluster\n#
    The method will return the total number only for a member in the cluster\n# ========================================================================\n#
    Check\n# echo $(get_total_nodes \"$PORT\")\n# => 6\n\nget_total_nodes() {\n    PORT=$1\n
    \   total=$(redis-cli -p \"$PORT\" cluster nodes | wc -l)\n    echo \"$total\"\n}\n\n#
    Returns the pod dns set\n# depends from the REPLICAS parameter\n# ===============================\n#
    Check\n# echo $(construct_initial_node_set \"6\" \"service_name\" \"namespace\"
    \"pod_name\")\n# => pod_name-0.service_name.namespace.svc.cluster.local ... pod_name-5.service_name.namespace.svc.cluster.local\n\nconstruct_initial_node_set()
    {\n    REPLICAS=$1\n    SERVICE_NAME=$2\n    NAMESPACE=$3\n    POD_NAME=$4\n\n
    \   result=$(\n        awk -v replicas=\"$REPLICAS\" -v service_name=\"$SERVICE_NAME\"
    -v namespace=\"$NAMESPACE\" -v pod_name=\"$POD_NAME\" '\n            BEGIN {\n
    \               sep = \"\"\n\n                for (i = 0; i < replicas; i++) {\n
    \                   printf(\"%s%s-%d.%s.%s.svc.cluster.local\", sep, pod_name,
    i, service_name, namespace)\n                    sep = \" \"\n                }\n
    \           }\n        '\n    )\n\n    echo \"$result\"\n}\n\n# Returns the pod
    dns set with port at the end\n# depends from the REPLICAS parameter\n# ====================================================\n#
    Check\n# echo $(construct_initial_node_set_port \"6\" \"service_name\" \"namespace\"
    \"pod_name\" \"6373\")\n# => pod_name-0.service_name.namespace.svc.cluster.local:6373
    ... pod_name-5.service_name.namespace.svc.cluster.local:6373\n\nconstruct_initial_node_set_port()
    {\n    REPLICAS=$1\n    SERVICE_NAME=$2\n    NAMESPACE=$3\n    POD_NAME=$4\n    PORT=$5\n\n
    \   result=$(\n        awk -v replicas=\"$REPLICAS\" -v service_name=\"$SERVICE_NAME\"
    -v namespace=\"$NAMESPACE\" -v pod_name=\"$POD_NAME\" -v port=\"$PORT\" '\n            BEGIN
    {\n                sep = \"\"\n\n                for (i = 0; i < replicas; i++)
    {\n                    printf(\"%s%s-%d.%s.%s.svc.cluster.local:%s\", sep, pod_name,
    i, service_name, namespace, port)\n                    sep = \" \"\n                }\n
    \           }\n        '\n    )\n\n\n    echo \"$result\"\n}\n\nconstruct_all_node_set()
    {\n    REPLICAS=$1\n    SERVICE_NAME=$2\n    NAMESPACE=$3\n    POD_NAME=$4\n\n
    \   total=$(get_total_nodes \"$PORT\")\n\n    result=$(\n        awk -v total=\"$REPLICAS\"
    -v service_name=\"$SERVICE_NAME\" -v namespace=\"$NAMESPACE\" -v pod_name=\"$POD_NAME\"
    '\n            BEGIN {\n                sep = \"\"\n\n                for (i =
    0; i < total; i++) {\n                    printf(\"%s%s-%d.%s.%s.svc.cluster.local\",
    sep, pod_name, i, service_name, namespace)\n                    sep = \" \"\n
    \               }\n            }\n        '\n    )\n\n    echo \"$result\"\n}\n\nconstruct_all_node_set_port()
    {\n    REPLICAS=$1\n    SERVICE_NAME=$2\n    NAMESPACE=$3\n    POD_NAME=$4\n    PORT=$5\n\n
    \   total=$(get_total_nodes \"$PORT\")\n\n    result=$(\n        awk -v total=\"$REPLICAS\"
    -v service_name=\"$SERVICE_NAME\" -v namespace=\"$NAMESPACE\" -v pod_name=\"$POD_NAME\"
    -v port=\"$PORT\" '\n            BEGIN {\n                sep = \"\"\n\n                for
    (i = 0; i < total; i++) {\n                    printf(\"%s%s-%d.%s.%s.svc.cluster.local:%s\",
    sep, pod_name, i, service_name, namespace, port)\n                    sep = \"
    \"\n                }\n            }\n        '\n    )\n\n    echo \"$result\"\n}\n\nconstruct_node_set()
    {\n    GROUP_SET=$1\n    SERVICE_NAME=$2\n    NAMESPACE=$3\n    POD_NAME=$4\n\n
    \   GROUP_SET_TRIM=$(echo \"$GROUP_SET\" | tr ',' ' ')\n\n    result=$(\n        echo
    \"$GROUP_SET_TRIM\" | awk -v service_name=\"$SERVICE_NAME\" -v namespace=\"$NAMESPACE\"
    -v pod_name=\"$POD_NAME\" '\n            {\n                sep = \"\"\n                for
    (i = 1; i <= NF; i++) {\n                    pod_n = $i - 1\n                    printf(\"%s%s-%s.%s.%s.svc.cluster.local\",
    sep, pod_name, pod_n, service_name, namespace)\n                    sep = \" \"\n
    \               }\n            }\n        '\n    )\n\n    echo \"$result\"\n}\n\nconstruct_node_set_port()
    {\n    GROUP_SET=$1\n    SERVICE_NAME=$2\n    NAMESPACE=$3\n    POD_NAME=$4\n
    \   PORT=$5\n\n    GROUP_SET_TRIM=$(echo \"$GROUP_SET\" | tr ',' ' ')\n\n    result=$(\n
    \       echo \"$GROUP_SET_TRIM\" | awk -v service_name=\"$SERVICE_NAME\" -v namespace=\"$NAMESPACE\"
    -v pod_name=\"$POD_NAME\" -v port=\"$PORT\" '\n            {\n                sep
    = \"\"\n                for (i = 1; i <= NF; i++) {\n                    pod_n
    = $i - 1\n                    printf(\"%s%s-%s.%s.%s.svc.cluster.local:%s\", sep,
    pod_name, pod_n, service_name, namespace, port)\n                    sep = \"
    \"\n                }\n            }\n        '\n    )\n\n    echo \"$result\"\n}\n\n#
    Returns the current pod k8s service DNS\n# ====================================================\n#
    Check\n# echo $(create_pod_dns)\n# => redis-node-0.redis-service.authentication.svc.cluster.local:6379\ncreate_pod_dns()
    {\n    POD_N=$((REDIS_NODE_ID - 1))\n    echo \"${POD_NAME}-${POD_N}.${SERVICE_NAME}.${NAMESPACE}.svc.cluster.local:${PORT}\"\n}\n\n#
    Returns the pod k8s service DNS based on the given replica number\n# Rememeber:
    POD Numbers start from 0. Redis nodes start from 1\n# ====================================================\n#
    Check\n# echo $(create_any_pod_dns \"5\")\n# => redis-node-4.redis-service.authentication.svc.cluster.local:6379\ncreate_any_pod_dns()
    {\n    REDIS_NODE_ID=\"$1\"\n    POD_N=$((REDIS_NODE_ID - 1))\n    echo \"${POD_NAME}-${POD_N}.${SERVICE_NAME}.${NAMESPACE}.svc.cluster.local:${PORT}\"\n}\n\n\n#
    Returns the count of pods based on given replicas number\n# ====================================================\n#
    Check\n# echo $(get_master_set_replicas \"5\")\n# => 6\nget_master_set_replicas()
    {\n    r=$(math_floor \"$1\")\n    echo $((r + 1))\n}\n\n\n# Returns the position
    in the pod group\n# ====================================================\n# Check\n#
    echo $(get_delta \"1\" \"3\") => 1 - set starts\n# echo $(get_delta \"2\" \"3\")
    => 2\n# echo $(get_delta \"3\" \"3\") => 3\n# echo $(get_delta \"4\" \"3\") =>
    4 - set ends\n# echo $(get_delta \"5\" \"3\") => 1 - new set start\n\nget_delta()
    {\n    node_num=$1\n    slaves=$2\n\n    pod_num=$((node_num - 1))\n\n    master_set=$(get_master_set_replicas
    \"$slaves\") # 1 master 1 slave = 2\n\n    if [ \"$node_num\" -eq 1 ]; then\n
    \       div=0\n    else\n        div=$(( pod_num / master_set ))\n    fi\n\n    delta=$((
    node_num - ( master_set * div) ))\n\n    echo \"$delta\"\n}\n\n# Returns the group
    master number\n# \n# If we have a group of nodes in the cluster: let say 1m 4f
    and if \n# we pass of the pod nums we will recieve the the master number in the
    group\n# ====================================================\n# If we have number
    11 of the node and 4 replicas it means that we have 5 nodes in the group (1m +
    4f)\n# If number 6 is the master node it means that the next master is 11 -> 6
    + 5 = 11\n# \n# Check\n# echo $(get_master_n \"2\" \"1\") => 6\n\n# echo $(get_master_n
    \"10\" \"4\") => 6\n# echo $(get_master_n \"11\" \"4\") => 11\n# echo $(get_master_n
    \"12\" \"4\") => 11\n# echo $(get_master_n \"13\" \"4\") => 11\n# echo $(get_master_n
    \"14\" \"4\") => 11\n# echo $(get_master_n \"15\" \"4\") => 11\n# echo $(get_master_n
    \"16\" \"4\") => 16\n\nget_master_n() {\n    node_num=$1\n    slaves=$2 # Indicates
    how many replicas the master has\n\n    delta=$(get_delta \"$node_num\" \"$slaves\")\n
    \   echo $((node_num - delta + 1))\n}\n\n# Returns the last memeber (f) in the
    group\n# \n# Similar to the get_master_n but returns the last number not the first
    one\n# ====================================================\n# echo $(get_last_slave_n
    \"10\" \"4\") => 10\n# echo $(get_last_slave_n \"11\" \"4\") => 15\n# echo $(get_last_slave_n
    \"12\" \"4\") => 15\n# echo $(get_last_slave_n \"13\" \"4\") => 15\n# echo $(get_last_slave_n
    \"14\" \"4\") => 15\n# echo $(get_last_slave_n \"15\" \"4\") => 15\n# echo $(get_last_slave_n
    \"16\" \"4\") => 20\nget_last_slave_n() {\n    pod_num=$1\n    slaves=$2\n\n    master_set=$(get_master_set_replicas
    \"$slaves\")\n    delta=$(get_delta \"$pod_num\" \"$slaves\")\n    div=$((master_set
    - delta))\n\n    echo $((pod_num + div))\n}\n\n# Returns all the pod numbers in
    the group\n# ====================================================\n# echo $(group_pods
    \"1\" \"4\") => 1,2,3,4,5\n# echo $(group_pods \"10\" \"4\") => 6,7,8,9,10\n#
    echo $(group_pods \"11\" \"4\") => 11,12,13,14,15\n# echo $(group_pods \"16\"
    \"4\") => 16,17,18,19,20\ngroup_pods() {\n    node_num=$1\n    slaves=$2\n    master_n=$(get_master_n
    \"$node_num\" \"$slaves\")\n\n    result=$(\n    awk -v master_n=\"$master_n\"
    -v slaves=\"$slaves\" '\n        BEGIN {\n            sep = \"\"\n            end
    = master_n + slaves + 1\n\n            for (i = master_n; i < end; i++) {\n                printf(\"%s%d\",
    sep, i)\n                sep = \",\"\n            }\n        }\n    '\n    )\n\n
    \   echo \"$result\"\n}\n\n# echo $(group_pods \"$node_num\" \"$slaves\")\n# echo
    $(get_master_n \"$node_num\" \"$slaves\")\n\n# Returns 0 | 1. Indicates is the
    given pod number a master\n# ====================================================\n#
    echo $(is_master \"1\" \"4\") => 1 - yes\n# echo $(is_master \"10\" \"4\") =>
    0 - no\nis_master() {\n    node_num=$1\n    slaves=$2\n\n    delta=$(get_delta
    \"$node_num\" \"$slaves\")\n    if [ \"$delta\" -eq 1 ]; then\n        echo \"1\"\n
    \   else\n        echo \"0\"\n    fi\n}\n\n# Returns 0 | 1. Indicates is the given
    node number a slave\n# ====================================================\n#
    echo $(is_slave \"1\" \"4\") => 0 - no\n# echo $(is_slave \"10\" \"4\") => 1 -
    yes\nis_slave() {\n    node_num=$1\n    slaves=$2\n\n    delta=$(get_delta \"$node_num\"
    \"$slaves\")\n    if [ \"$delta\" -eq 1 ]; then\n        echo \"0\"\n    else\n
    \       echo \"1\"\n    fi\n}\n\n# Returns 0 | 1. Indicates is the given node
    number the last slave\n# ====================================================\n#
    Check\n# echo $(is_last_slave \"1\" \"3\") => 0 - set starts NO\n# echo $(is_last_slave
    \"2\" \"3\") => 0 - NO\n# echo $(is_last_slave \"3\" \"3\") => 0 - NO\n# echo
    $(is_last_slave \"4\" \"3\") => 1 - set ends YES\n# echo $(is_last_slave \"5\"
    \"3\") => 0 - new set start NO\nis_last_slave() {\n    node_num=$1\n    slaves=$2\n
    \   master_set=$(get_master_set_replicas \"$slaves\")\n\n    delta=$(get_delta
    \"$node_num\" \"$slaves\")\n    if [ \"$delta\" -eq \"$master_set\" ]; then\n
    \       echo \"1\"\n    else\n        echo \"0\"\n    fi\n}\n\n"
  prestop.sh: |-
    #!/bin/sh

    # https://redis.io/docs/latest/operate/oss_and_stack/management/scaling/#reshard-the-cluster

    set -e

    PORT=${PORT:-6379}
    CLUSTER_NODE_TIMEOUT=${CLUSTER_NODE_TIMEOUT:-5000}
    POD_INDEX=${POD_NAME_INDEX##*-}
    REDIS_NODE_ID=$(expr "$POD_INDEX" + 1)
    POD_NAME="${POD_NAME_INDEX%-[0-9]*}"

    if [ -z "$MOUNT_POINT" ]; then
        printf "MOUNT_POINT is missing: Please privide value!"
        exit 1
    fi

    if [ -z "$POD_NAME" ]; then
        printf "POD_NAME is missing: Please privide value!"
        exit 1
    fi

    if [ -z "$REPLICAS" ]; then
        printf "REPLICAS is missing: Please privide value!"
        exit 1
    fi

    if [ -z "$CLUSTER_REPLICAS" ]; then
        printf "CLUSTER_REPLICAS is missing: Please privide value!"
        exit 1
    fi

    if [ -z "$SERVICE_NAME" ]; then
        printf "SERVICE_NAME is missing: Please privide value!"
        exit 1
    fi

    if [ -z "$NAMESPACE" ]; then
        printf "NAMESPACE is missing: Please privide value!"
        exit 1
    fi

    if [ -z "$NAMESPACE" ]; then
        printf "NAMESPACE is missing: Please privide value!"
        exit 1
    fi


    LOG_FILE="/mnt/prestop.log"

    echo "[INFO] Starting prestop hook at $(date)" >> "$LOG_FILE" 2>&1


    . "$MOUNT_POINT/global_tools.sh"
    . "$MOUNT_POINT/cluster_tools.sh"
    . "$MOUNT_POINT/orchestrate.sh"
    . "$MOUNT_POINT/cluster_health.sh"

    print_green "Scale down starting" 1

    remove_pod_from_cluster() {
        print_green "Preparing for pod removing: $POD_NAME from Redis cluster..." 1

        IS_MASTER=$(is_master "$REDIS_NODE_ID" "$CLUSTER_REPLICAS")

        # 0. Wait until cluster is ready
        operation_loop

        # 1. If master, move all slots to other masters
        if [ "$IS_MASTER" -eq 1 ]; then
            print_green "Pod is a master. Migrating slots before removal..." 1
            move_all_slots_to_masters

            # 2. Delete node from the cluster
            delete_current_cluster_node

            call_rebalance
        else
            print_green "Pod is not a master. Proceeding with removal..." 1

            # 2. Delete node from the cluster
            delete_current_cluster_node
        fi

        operation_loop

        print_green "Pod $POD_NAME removed from Redis cluster successfully." 1
    }

    remove_pod_from_cluster  >> "$LOG_FILE" 2>&1

    touch /tmp/prestop-done
  timestamp: "2025-07-07T14:34:04Z"
kind: ConfigMap
metadata:
  name: '{{ .Values.configMapName }}'
  namespace: '{{ .Values.namespace }}'
